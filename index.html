<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poster editor — fixed (text above photo, visible controls)</title>
<style>
  :root{
    --poster-width: 800px;
    --poster-height: 1200px;
    --slot-right: 60px;
    --slot-top: 120px;
    --slot-width: 360px;
    --slot-height: 820px;
  }
  body{
    display:flex;
    justify-content:center;
    padding:20px;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    background:#f3f4f6;
  }

  /* Poster frame with background image as an <img> for consistent rendering */
  .poster-frame {
    width: var(--poster-width);
    height: var(--poster-height);
    position: relative;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 12px 30px rgba(0,0,0,0.25);
    background: #fff;
  }
  /* background image layer (cover) */
  .poster-frame .bg {
    position:absolute;
    left:0; top:0; width:100%; height:100%;
    object-fit:cover;
    object-position:center;
    z-index:1;
    pointer-events:none;
    filter: none;
  }

  /* Content layer (texts) must be above photo-slot */
  .content {
    position: absolute;
    left: 28px;
    top: 28px;
    right: 28px;
    bottom: 28px;
    z-index: 40; /* text / UI above photo slot */
    pointer-events: none; /* allow pointer to pass to slot when needed; override for editable controls */
  }

  /* Headline (editable) */
  .headline {
    color: #ffffff;
    text-shadow: 0 4px 12px rgba(0,0,0,0.45);
    pointer-events: auto; /* allow editing */
  }
  .headline h1 { margin:0; font-size:64px; letter-spacing:.5px; }
  .headline p { margin:8px 0 0 0; font-size:22px; color: rgba(255,255,255,0.95) }

  /* Info box — white translucent box for readability */
  .info {
    margin-top: 120px;
    width: 420px;
    background: rgba(255,255,255,0.92);
    padding: 18px;
    border-radius: 10px;
    color: #06314d;
    box-shadow: 0 8px 26px rgba(7,22,45,0.08);
    pointer-events: auto; /* allow editing */
  }
  .info h2{ margin:0 0 8px 0; font-size:20px; color:#0b3a61; }
  .info ul{ margin:8px 0 0 18px; }
  .info li{ margin:8px 0; line-height:1.35; }

  /* Photo slot positioned to the right; placed under text layer (z-index lower) */
  .photo-slot {
    position: absolute;
    right: var(--slot-right);
    top: var(--slot-top);
    width: var(--slot-width);
    height: var(--slot-height);
    border-radius: 18px;
    overflow: hidden;
    box-shadow: 0 8px 30px rgba(0,0,0,0.25);
    z-index: 20; /* BELOW the .content (which is z-index:40) so text remains visible on top */
    display:flex;
    align-items:center;
    justify-content:center;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.02));
    pointer-events: auto;
  }

  .photo-slot img.user {
    width:100%;
    height:100%;
    object-fit:cover;
    object-position:center;
    display:block;
    transform-origin:center;
    transition: transform 0.15s ease;
    will-change: transform;
  }

  /* bottom fade overlay inside slot to match poster fade look */
  .photo-slot::after{
    content:"";
    position:absolute; left:0; right:0; bottom:0;
    height:32%;
    pointer-events:none;
    background: linear-gradient(to bottom, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%);
    opacity:0.85; /* tweak for blend */
  }

  /* Controls area pinned bottom-right */
  .controls {
    position: absolute;
    right: 18px;
    bottom: 18px;
    z-index: 60;
    display:flex;
    gap:8px;
    align-items:center;
    pointer-events: auto;
  }
  .controls input[type=file]{ display:block; }
  .controls button{
    background:#0a58ca;
    color:white;
    border:none;
    padding:10px 12px;
    border-radius:8px;
    cursor:pointer;
    font-weight:600;
    box-shadow: 0 6px 18px rgba(10,88,202,0.18);
  }
  .controls button:active{ transform: translateY(1px); }

  /* Make sure zoom - is visible (small square icons) */
  .zoom-btn { width:44px; height:44px; display:inline-flex; align-items:center; justify-content:center; font-size:18px; padding:0; }

  /* Small placeholder when no photo */
  .photo-slot .placeholder{
    color: rgba(0,0,0,0.45);
    font-weight:700;
    text-align:center;
    padding:16px;
    width:100%;
  }

  /* Responsive adjustments */
  @media (max-width:900px){
    :root{ --poster-width:360px; --poster-height:640px; --slot-width:150px; --slot-height:300px; --slot-top:90px; --slot-right:22px;}
    .headline h1{ font-size:36px; }
    .info{ width:230px; margin-top:100px; }
    .controls{ right:12px; bottom:12px; gap:6px; }
  }
</style>
</head>
<body>
  <div class="poster-frame" id="poster">
    <!-- Background image layer: replace 'background.jpg' with your cleaned poster background (no man) -->
    <img class="bg" id="bgImage" src="background.jpg" alt="Poster background">

    <!-- photo slot sits above background but under content so text overlays on top -->
    <div class="photo-slot" id="slot" title="Drop or click to upload image">
      <img class="user" id="userImage" src="" alt="" style="display:none">
      <div class="placeholder" id="placeholder">Drop or upload your photo here</div>
    </div>

    <!-- content (texts) that should stay above the photo -->
    <div class="content">
      <div class="headline" style="pointer-events:auto;">
        <h1 contenteditable="true" id="title">HAPPY</h1>
        <p contenteditable="true" id="sub">Birthday Christopher</p>
      </div>

      <div class="info" style="pointer-events:auto;">
        <h2 contenteditable="true" id="tag">A blessed day!</h2>
        <ul id="bullets">
          <li contenteditable="true">The Lord bless you and keep you</li>
          <li contenteditable="true">The Lord make His face shine upon you</li>
          <li contenteditable="true">Numbers 6:24–26</li>
        </ul>
      </div>
    </div>

    <!-- controls -->
    <div class="controls" id="controls">
      <input id="fileInput" type="file" accept="image/*">
      <button id="zoomOut" class="zoom-btn" title="Zoom out">−</button>
      <button id="zoomIn" class="zoom-btn" title="Zoom in">+</button>
      <button id="downloadBtn" title="Export PNG">Export</button>
    </div>
  </div>

<script>
  // Basic image handling — upload, show, zoom, drag
  const fileInput = document.getElementById('fileInput');
  const userImage = document.getElementById('userImage');
  const placeholder = document.getElementById('placeholder');
  const slot = document.getElementById('slot');
  const poster = document.getElementById('poster');
  let scale = 1;
  let lastX = 0, lastY = 0;
  let dragging = false, startX=0, startY=0;

  // show uploaded image
  fileInput.addEventListener('change', e=>{
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = ev=>{
      userImage.src = ev.target.result;
      userImage.style.display = 'block';
      placeholder.style.display = 'none';
      scale = 1; lastX = 0; lastY = 0;
      userImage.style.transform = `translate(0px,0px) scale(${scale})`;
    }
    reader.readAsDataURL(f);
  });

  // allow dropping files into slot
  slot.addEventListener('dragover', ev=>{ ev.preventDefault(); slot.style.opacity = 0.95; });
  slot.addEventListener('dragleave', ev=>{ slot.style.opacity = 1; });
  slot.addEventListener('drop', ev=>{ ev.preventDefault(); slot.style.opacity = 1;
    const f = ev.dataTransfer.files && ev.dataTransfer.files[0];
    if(!f) return;
    const reader = new FileReader();
    reader.onload = e=>{ userImage.src = e.target.result; userImage.style.display='block'; placeholder.style.display='none'; scale=1; lastX=0; lastY=0; userImage.style.transform = `translate(0px,0px) scale(${scale})`; };
    reader.readAsDataURL(f);
  });

  // zoom
  document.getElementById('zoomIn').addEventListener('click', ()=>{
    scale = Math.min(3.5, scale + 0.1);
    userImage.style.transform = `translate(${lastX}px, ${lastY}px) scale(${scale})`;
  });
  document.getElementById('zoomOut').addEventListener('click', ()=>{
    scale = Math.max(0.5, scale - 0.1);
    userImage.style.transform = `translate(${lastX}px, ${lastY}px) scale(${scale})`;
  });

  // drag the image inside the slot
  slot.addEventListener('pointerdown', ev=>{
    if(userImage.style.display === 'none') return;
    dragging = true;
    startX = ev.clientX;
    startY = ev.clientY;
    slot.setPointerCapture(ev.pointerId);
  });
  window.addEventListener('pointermove', ev=>{
    if(!dragging) return;
    const dx = ev.clientX - startX;
    const dy = ev.clientY - startY;
    userImage.style.transform = `translate(${lastX + dx}px, ${lastY + dy}px) scale(${scale})`;
  });
  window.addEventListener('pointerup', ev=>{
    if(!dragging) return;
    const dx = ev.clientX - startX;
    const dy = ev.clientY - startY;
    lastX += dx; lastY += dy;
    dragging = false;
    slot.releasePointerCapture && slot.releasePointerCapture();
  });

  // Export: draw background image (bg), user image and text onto canvas
  document.getElementById('downloadBtn').addEventListener('click', async ()=>{
    try{
      const w = poster.clientWidth;
      const h = poster.clientHeight;
      const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');

      // draw bg image from <img class="bg">
      const bgImgEl = document.getElementById('bgImage');
      if(bgImgEl && bgImgEl.src){
        const bg = await loadImage(bgImgEl.src);
        ctx.drawImage(bg, 0, 0, w, h);
      } else {
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,w,h);
      }

      // draw user image into slot if present
      if(userImage && userImage.src){
        const img = await loadImage(userImage.src);
        const slotRect = slot.getBoundingClientRect();
        const posterRect = poster.getBoundingClientRect();
        const sx = slotRect.left - posterRect.left;
        const sy = slotRect.top - posterRect.top;
        const sw = slotRect.width;
        const sh = slotRect.height;

        // Because user can drag/zoom we try to compute transform from CSS transform value.
        // Fallback: draw cover-style centered if transform parse fails.
        // Attempt to parse translate/scale from style
        let transform = userImage.style.transform || '';
        const m = transform.match(/translate\(([-0-9.]+)px,\s*([-0-9.]+)px\)\s*scale\(([-0-9.]+)\)/) ||
                  transform.match(/translate\(([-0-9.]+)px,\s*([-0-9.]+)px\)\s*scale\(([-0-9.]+)\)/i);
        if(m){
          const tx = parseFloat(m[1]), ty = parseFloat(m[2]), s = parseFloat(m[3]);
          // draw image centered then apply transformations by drawing into offscreen canvas
          const off = document.createElement('canvas');
          off.width = img.width; off.height = img.height;
          const oc = off.getContext('2d');
          oc.drawImage(img,0,0);
          // compute scale to fill slot (cover) BEFORE user scale
          const imgRatio = img.width / img.height;
          const slotRatio = sw / sh;
          let drawW, drawH;
          if(imgRatio > slotRatio){
            drawH = sh; drawW = img.width * (sh / img.height);
          } else {
            drawW = sw; drawH = img.height * (sw / img.width);
          }
          // draw with transform. Simpler approach: draw into canvas using drawImage with computed offsets
          // We'll center the "cover" then apply user translate & scale relative to slot
          const baseScale = drawW / img.width;
          const finalScale = baseScale * s;
          const drawWidth = img.width * finalScale;
          const drawHeight = img.height * finalScale;
          // user translations are in pixels relative to slot; apply them
          const dx = sx + (sw - drawWidth)/2 + tx;
          const dy = sy + (sh - drawHeight)/2 + ty;
          ctx.drawImage(img, dx, dy, drawWidth, drawHeight);
        } else {
          // fallback: object-fit: cover draw center
          const imgRatio = img.width / img.height;
          const slotRatio = sw / sh;
          let drawW, drawH, dx, dy;
          if (imgRatio > slotRatio) {
            drawH = sh;
            drawW = img.width * (sh / img.height);
            dx = sx - (drawW - sw)/2;
            dy = sy;
          } else {
            drawW = sw;
            drawH = img.height * (sw / img.width);
            dx = sx;
            dy = sy - (drawH - sh)/2;
          }
          ctx.drawImage(img, dx, dy, drawW, drawH);
        }

        // draw bottom fade over slot area
        const grad = ctx.createLinearGradient(0, sy + sh*0.6, 0, sy + sh);
        grad.addColorStop(0, 'rgba(255,255,255,0)');
        grad.addColorStop(1, 'rgba(255,255,255,1)');
        ctx.fillStyle = grad;
        ctx.fillRect(sx, sy + sh*0.6, sw, sh*0.4);
      }

      // Draw texts: simple approach, read innerText and draw — adjust positions as needed
      ctx.fillStyle = '#ffffff';
      ctx.font = 'bold 64px system-ui';
      ctx.fillText(document.getElementById('title').innerText.trim(), 40, 90);
      ctx.font = '20px system-ui';
      ctx.fillText(document.getElementById('sub').innerText.trim(), 40, 130);

      // bullets area draw
      ctx.fillStyle = '#08314e';
      ctx.font = 'bold 20px system-ui';
      const bullets = Array.from(document.querySelectorAll('#bullets li')).map(li=>li.innerText.trim());
      ctx.font = '18px system-ui';
      let y = 200;
      for(const b of bullets){
        ctx.fillText('• ' + b, 40, y);
        y += 28;
      }

      // trigger download
      const a = document.createElement('a'); a.download = 'poster_export.png'; a.href = canvas.toDataURL('image/png'); a.click();

    } catch(err){
      alert('Export failed: ' + err.message + '\nMake sure the background image (background.jpg) is accessible.');
      console.error(err);
    }
  });

  function loadImage(src){
    return new Promise((res, rej)=>{
      const i = new Image();
      i.crossOrigin = 'anonymous';
      i.onload = ()=>res(i);
      i.onerror = e=>rej(e);
      i.src = src;
    });
  }
</script>
</body>
        </html>
