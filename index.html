<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Poster Editor — Translucent Text Backgrounds</title>
<style>
  :root {
    --poster-width: 800px;
    --poster-height: 1200px;
    --slot-right: 70px;
    --slot-top: 160px;
    --slot-width: 360px;
    --slot-height: 720px;
    --left-margin: 40px;
  }
  * { box-sizing: border-box; }
  body {
    display: flex;
    justify-content: center;
    padding: 20px;
    background: #f3f4f6;
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    margin: 0;
  }
  .poster-frame {
    width: var(--poster-width);
    height: var(--poster-height);
    position: relative;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
    background: #fff;
  }

  .poster-frame .bg {
    position: absolute;
    inset: 0;
    width:100%;
    height:100%;
    object-fit: cover;
    z-index: 1;
    pointer-events: none;
  }

  /* Headline now has a translucent rounded background */
  .headline {
    position: absolute;
    top: 40px;
    left: var(--left-margin);
    z-index: 60; /* above photo */
    color: #fff;
    text-shadow: 0 3px 10px rgba(0, 0, 0, 0.45);
    max-width: calc(100% - var(--slot-width) - var(--slot-right) - 80px);
    background: rgba(255,255,255,0.12); /* translucent */
    padding: 14px 18px;
    border-radius: 14px;
    backdrop-filter: blur(6px); /* soft blur behind text (modern browsers) */
  }
  .headline h1 {
    margin: 0;
    font-size: 64px;
    line-height: 0.95;
    word-break: break-word;
  }
  .headline p {
    margin: 8px 0 0 0;
    font-size: 22px;
    color: rgba(255, 255, 255, 0.95);
  }

  .photo-slot {
    position: absolute;
    right: var(--slot-right);
    top: var(--slot-top);
    width: var(--slot-width);
    height: var(--slot-height);
    border-radius: 18px;
    overflow: hidden;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    z-index: 50; /* under headline but above bg */
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(255, 255, 255, 0.02);
  }

  .photo-slot img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    transform-origin: center;
    transition: transform 0.15s ease;
    display:block;
  }
  .photo-slot::after {
    content: "";
    position: absolute;
    inset: auto 0 0 0;
    height: 30%;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0) 0%, rgba(255,255,255,1) 100%);
    opacity: 0.85;
    pointer-events: none;
  }

  /* Info box translucent */
  .info {
    position: absolute;
    left: 40px;
    bottom: 60px;
    width: calc(100% - 100px);
    max-width: 700px;
    background: rgba(255, 255, 255, 0.78); /* more translucent */
    color: #0b3a61;
    border-radius: 10px;
    padding: 18px 22px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
    z-index: 60;
    backdrop-filter: blur(3px);
  }
  .info h2 {
    margin: 0 0 8px 0;
    font-size: 20px;
  }
  .info ul {
    margin: 5px 0 0 18px;
    padding: 0;
  }
  .info li {
    margin: 5px 0;
    line-height: 1.35;
  }

  /* Upload and controls */
  .controls {
    position: absolute;
    bottom: 15px;
    right: 20px;
    z-index: 70;
    display: flex;
    gap: 8px;
    align-items:center;
  }
  .controls input {
    display: none;
  }
  .controls label,
  .controls button {
    background: #0a58ca;
    color: white;
    border: none;
    border-radius: 8px;
    padding: 8px 12px;
    font-weight: 600;
    cursor: pointer;
  }
  .controls .zoom-btn {
    width: 44px;
    height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
  }

  /* small placeholder text */
  #placeholder { color:#555; font-weight:600; text-align:center; padding:8px; }

  @media (max-width: 900px) {
    :root {
      --poster-width: 360px;
      --poster-height: 640px;
      --slot-width: 150px;
      --slot-height: 320px;
      --slot-top: 90px;
      --slot-right: 20px;
    }
    .headline h1 { font-size: 36px; }
    .info { width: calc(100% - 60px); left: 30px; bottom: 25px; }
  }
</style>
</head>
<body>
  <div class="poster-frame" id="poster">
    <!-- Replace with your poster background file in same folder -->
    <img src="IMG-20251105-WA0012.jpg" alt="Poster background" class="bg" id="bgImage">

    <div class="photo-slot" id="slot">
      <img id="userImage" alt="Uploaded photo" style="display:none" />
      <div id="placeholder">Upload photo here</div>
    </div>

    <div class="headline">
      <h1 contenteditable="true" id="title">HAPPY</h1>
      <p contenteditable="true" id="sub">Birthday Christopher</p>
    </div>

    <div class="info">
      <h2 contenteditable="true" id="tag">A blessed day!</h2>
      <ul id="bullets">
        <li contenteditable="true">The Lord bless you and keep you</li>
        <li contenteditable="true">The Lord make His face shine upon you</li>
        <li contenteditable="true">Numbers 6:24–26</li>
      </ul>
    </div>

    <div class="controls">
      <label for="fileInput" style="cursor:pointer;">Choose Photo</label>
      <input type="file" id="fileInput" accept="image/*" />
      <button id="removeBgBtn" disabled>Remove BG</button>
      <button class="zoom-btn" id="zoomOut">−</button>
      <button class="zoom-btn" id="zoomIn">+</button>
      <button id="downloadBtn">Export</button>
    </div>
  </div>

<!-- TensorFlow + BodyPix (loads model) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.5/dist/body-pix.js"></script>

<script>
/* ---------- UI: upload, zoom, drag ---------- */
const fileInput = document.getElementById('fileInput');
const userImage = document.getElementById('userImage');
const placeholder = document.getElementById('placeholder');
const slot = document.getElementById('slot');
const poster = document.getElementById('poster');
let scale = 1, translateX = 0, translateY = 0, dragging = false, startX = 0, startY = 0;

fileInput.addEventListener('change', e => {
  const file = e.target.files && e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = ev => {
    userImage.src = ev.target.result;
    userImage.style.display = 'block';
    placeholder.style.display = 'none';
    scale = 1; translateX = translateY = 0;
    updateTransform();
  };
  reader.readAsDataURL(file);
});

slot.addEventListener('dragover', e => { e.preventDefault(); slot.style.opacity = 0.98; });
slot.addEventListener('dragleave', e => { slot.style.opacity = 1; });
slot.addEventListener('drop', e => {
  e.preventDefault(); slot.style.opacity = 1;
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if (!f) return;
  const reader = new FileReader();
  reader.onload = ev => {
    userImage.src = ev.target.result;
    userImage.style.display = 'block';
    placeholder.style.display = 'none';
    scale = 1; translateX = translateY = 0;
    updateTransform();
  };
  reader.readAsDataURL(f);
});

function updateTransform(){
  userImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
}

// pointer drag for repositioning
slot.addEventListener('pointerdown', e => {
  if (userImage.style.display === 'none') return;
  dragging = true;
  startX = e.clientX; startY = e.clientY;
  slot.setPointerCapture && slot.setPointerCapture(e.pointerId);
});
window.addEventListener('pointermove', e => {
  if (!dragging) return;
  translateX += e.clientX - startX;
  translateY += e.clientY - startY;
  startX = e.clientX; startY = e.clientY;
  updateTransform();
});
window.addEventListener('pointerup', e => { dragging = false; });

// zoom
document.getElementById('zoomIn').addEventListener('click', ()=>{ scale = Math.min(3.5, scale + 0.1); updateTransform(); });
document.getElementById('zoomOut').addEventListener('click', ()=>{ scale = Math.max(0.5, scale - 0.1); updateTransform(); });

/* ---------- BodyPix background removal (client-side) ---------- */
let bodyPixNet = null;
let bgRemoving = false;

async function enableRemoveButtonWhenReady(){
  const btn = document.getElementById('removeBgBtn');
  if (btn) {
    btn.disabled = false;
    btn.innerText = 'Remove BG';
  } else {
    setTimeout(enableRemoveButtonWhenReady, 300);
  }
}

async function setupBgRemoval(){
  try {
    console.log('Loading BodyPix model...');
    bodyPixNet = await bodyPix.load({
      architecture: 'MobileNetV1',
      outputStride: 16,
      multiplier: 0.75,
      quantBytes: 2
    });
    console.log('BodyPix loaded');
    enableRemoveButtonWhenReady();
  } catch(err){
    console.error('BodyPix load failed', err);
    alert('Background-removal model failed to load. Try reloading the page.');
  }
}

async function removeBackgroundFromUserImage(){
  if (!bodyPixNet) { alert('Model loading — wait a moment and try again'); return; }
  if (bgRemoving) return;
  const userImageEl = document.getElementById('userImage');
  if (!userImageEl || !userImageEl.src) { alert('Upload a photo first'); return; }
  bgRemoving = true;
  const btn = document.getElementById('removeBgBtn');
  if (btn) { btn.innerText = 'Removing…'; btn.disabled = true; }
  try {
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = userImageEl.src;
    await new Promise((res, rej)=>{ img.onload = res; img.onerror = rej; });

    const segmentation = await bodyPixNet.segmentPerson(img, {
      flipHorizontal: false,
      internalResolution: 'medium',
      segmentationThreshold: 0.7
    });

    const w = img.naturalWidth, h = img.naturalHeight;
    const out = document.createElement('canvas'); out.width = w; out.height = h;
    const ctx = out.getContext('2d');
    ctx.drawImage(img, 0, 0, w, h);
    const imageData = ctx.getImageData(0,0,w,h);
    const pix = imageData.data;
    const seg = segmentation.data;
    for (let i=0, p=0; i<seg.length; i++, p+=4){
      const isPerson = seg[i] === 1;
      if (!isPerson) pix[p+3] = 0; else pix[p+3] = 255;
    }
    ctx.putImageData(imageData, 0, 0);
    userImageEl.src = out.toDataURL('image/png');
    userImageEl.style.display = 'block';
    placeholder.style.display = 'none';
  } catch(err){
    console.error(err);
    alert('Background removal failed. See console for details.');
  } finally {
    bgRemoving = false;
    if (btn) { btn.disabled = false; btn.innerText = 'Remove BG'; }
  }
}

/* wire remove button after DOM ready */
document.addEventListener('DOMContentLoaded', ()=>{
  const removeBtn = document.getElementById('removeBgBtn');
  if (removeBtn) removeBtn.addEventListener('click', removeBackgroundFromUserImage);
  // start loading model
  setupBgRemoval();
});

/* ---------- Improved Export (draw UI elements to canvas to match screenshot) ---------- */
function roundedRectPath(ctx, x, y, width, height, r) {
  const min = Math.min(width, height) / 2;
  if (r > min) r = min;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + width, y, x + width, y + height, r);
  ctx.arcTo(x + width, y + height, x, y + height, r);
  ctx.arcTo(x, y + height, x, y, r);
  ctx.arcTo(x, y, x + width, y, r);
  ctx.closePath();
}
function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
  const words = text.split(' ');
  let line = '';
  for (let n = 0; n < words.length; n++) {
    const testLine = line + words[n] + ' ';
    const metrics = ctx.measureText(testLine);
    if (metrics.width > maxWidth && n > 0) {
      ctx.fillText(line.trim(), x, y);
      line = words[n] + ' ';
      y += lineHeight;
    } else {
      line = testLine;
    }
  }
  if (line) ctx.fillText(line.trim(), x, y);
  return y;
}

function loadImage(src){
  return new Promise((res, rej)=>{
    const i = new Image();
    i.crossOrigin = 'anonymous';
    i.onload = ()=>res(i);
    i.onerror = rej;
    i.src = src;
  });
}

document.getElementById('downloadBtn').addEventListener('click', async () => {
  try {
    const posterEl = document.getElementById('poster');
    const w = posterEl.clientWidth, h = posterEl.clientHeight;
    const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext('2d');

    // draw background
    const bgEl = document.getElementById('bgImage');
    if (bgEl && bgEl.src) {
      const bgImg = await loadImage(bgEl.src);
      ctx.drawImage(bgImg, 0, 0, w, h);
    } else {
      ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h);
    }

    // slot geometry
    const slotRect = slot.getBoundingClientRect();
    const posterRect = posterEl.getBoundingClientRect();
    const sx = Math.round(slotRect.left - posterRect.left);
    const sy = Math.round(slotRect.top - posterRect.top);
    const sw = Math.round(slotRect.width);
    const sh = Math.round(slotRect.height);
    const cornerRadius = 18;

    // draw photo card shadow + white card
    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.28)';
    ctx.shadowBlur = 20;
    ctx.shadowOffsetY = 8;
    ctx.fillStyle = 'rgba(255,255,255,0.96)';
    roundedRectPath(ctx, sx, sy, sw, sh, cornerRadius);
    ctx.fill();
    ctx.restore();

    // draw user image clipped
    if (userImage && userImage.src) {
      const img = await loadImage(userImage.src);

      const imgRatio = img.width / img.height;
      const slotRatio = sw / sh;
      let baseDrawW, baseDrawH, baseDX, baseDY;
      if (imgRatio > slotRatio) {
        baseDrawH = sh;
        baseDrawW = img.width * (sh / img.height);
        baseDX = sx - (baseDrawW - sw) / 2;
        baseDY = sy;
      } else {
        baseDrawW = sw;
        baseDrawH = img.height * (sw / img.width);
        baseDX = sx;
        baseDY = sy - (baseDrawH - sh) / 2;
      }

      // parse transform translate/scale
      let tx = 0, ty = 0, s = 1;
      const t = userImage.style.transform || '';
      const m = t.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)\s*scale\(([\d.]+)\)/);
      if (m) { tx = parseFloat(m[1]); ty = parseFloat(m[2]); s = parseFloat(m[3]); }
      else {
        const sMatch = t.match(/scale\(([\d.]+)\)/);
        const xMatch = t.match(/translateX\(([-\d.]+)px\)/);
        const yMatch = t.match(/translateY\(([-\d.]+)px\)/);
        if (sMatch) s = parseFloat(sMatch[1]);
        if (xMatch) tx = parseFloat(xMatch[1]);
        if (yMatch) ty = parseFloat(yMatch[1]);
      }

      const finalW = baseDrawW * s;
      const finalH = baseDrawH * s;
      const finalX = baseDX + tx + (sw - baseDrawW)/2;
      const finalY = baseDY + ty;

      ctx.save();
      roundedRectPath(ctx, sx, sy, sw, sh, cornerRadius);
      ctx.clip();
      ctx.drawImage(img, finalX, finalY, finalW, finalH);

      // bottom fade
      const grad = ctx.createLinearGradient(0, sy + sh * 0.6, 0, sy + sh);
      grad.addColorStop(0, 'rgba(255,255,255,0)');
      grad.addColorStop(1, 'rgba(255,255,255,1)');
      ctx.fillStyle = grad;
      ctx.fillRect(sx, sy + sh * 0.6, sw, sh * 0.4);

      ctx.restore();

      // small ellipse shadow under card (soft)
      ctx.save();
      ctx.globalCompositeOperation = 'destination-over';
      ctx.fillStyle = 'rgba(0,0,0,0.06)';
      const ellipseW = sw * 0.9, ellipseH = 22;
      const ellX = sx + (sw - ellipseW) / 2, ellY = sy + sh - 10;
      ctx.beginPath();
      ctx.ellipse(ellX + ellipseW/2, ellY + ellipseH/2, ellipseW/2, ellipseH/2, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // draw info card (use on-screen position) - translucent
    const infoEl = document.querySelector('.info');
    const infoRect = infoEl.getBoundingClientRect();
    const infoX = Math.round(infoRect.left - posterRect.left);
    const infoY = Math.round(infoRect.top - posterRect.top);
    const infoW = Math.round(infoRect.width);
    const infoH = Math.round(infoRect.height);

    ctx.save();
    ctx.shadowColor = 'rgba(0,0,0,0.12)';
    ctx.shadowBlur = 20;
    ctx.shadowOffsetY = 8;
    ctx.fillStyle = 'rgba(255,255,255,0.78)'; // translucent like CSS
    roundedRectPath(ctx, infoX, infoY, infoW, infoH, 10);
    ctx.fill();
    ctx.restore();

    // draw translucent rectangle behind title (so headline has translucent background in export)
    const title = document.getElementById('title').innerText.trim();
    const subtitle = document.getElementById('sub').innerText.trim();
    const leftMargin = 40;
    const titleMaxWidth = Math.max(100, sx - leftMargin - 24);
    const titleBoxHeight = 110;
    const titleBoxX = leftMargin - 12;
    const titleBoxY = 22;
    const titleBoxW = titleMaxWidth + 24;

    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.12)'; // translucent
    roundedRectPath(ctx, titleBoxX, titleBoxY, titleBoxW, titleBoxHeight, 14);
    ctx.fill();
    ctx.restore();

    // draw title with shadow
    ctx.save();
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 64px system-ui';
    ctx.shadowColor = 'rgba(0,0,0,0.45)';
    ctx.shadowBlur = 12;
    ctx.shadowOffsetY = 4;
    wrapText(ctx, title, leftMargin, 90, titleMaxWidth, 72);
    ctx.restore();

    // subtitle
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.font = '20px system-ui';
    ctx.fillText(subtitle, leftMargin, 130, titleMaxWidth);
    ctx.restore();

    // draw info text inside info card
    ctx.save();
    ctx.fillStyle = '#08314e';
    ctx.font = 'bold 20px system-ui';
    ctx.fillText(document.getElementById('tag').innerText.trim(), infoX + 20, infoY + 34);
    ctx.font = '18px system-ui';
    let yy = infoY + 34 + 28;
    const bullets = Array.from(document.querySelectorAll('#bullets li')).map(li => li.innerText.trim());
    for (const b of bullets) {
      ctx.fillText('• ' + b, infoX + 20, yy, infoW - 40);
      yy += 26;
    }
    ctx.restore();

    // export
    const link = document.createElement('a');
    link.download = 'poster_export.png';
    link.href = canvas.toDataURL('image/png');
    link.click();

  } catch (err) {
    console.error('Export error', err);
    alert('Export failed: ' + err.message);
  }
});
</script>
</body>
  </html>
